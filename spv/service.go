package spv

import (
	"bytes"
	"errors"
	"fmt"
	"sync"

	"github.com/elastos/Elastos.ELA.SideChain/types"

	"github.com/elastos/Elastos.ELA.SPV/bloom"
	spv "github.com/elastos/Elastos.ELA.SPV/interface"
	"github.com/elastos/Elastos.ELA.Utility/common"
	"github.com/elastos/Elastos.ELA/core"
)

const (
	minConnections = 8
	maxConnections = 125
)

type Config struct {
	// The magic number that specify which network to connect.
	Magic uint32

	// The foundation address of the genesis block, which is different between
	// MainNet, TestNet, RegNet etc.
	Foundation string

	// The public seed peers addresses.
	SeedList []string

	// NodePort is the default port for public peers provide services.
	DefaultPort uint16

	// GenesisAddress is the address generated by the side chain genesis block.
	GenesisAddress string

	// txStore is the database to store transactions received by SPV service.
	TxStore *txStore
}

type Service struct {
	spv.SPVService
	db *txStore
}

func NewService(cfg *Config) (*Service, error) {
	spvCfg := spv.Config{
		Magic:          cfg.Magic,
		Foundation:     cfg.Foundation,
		SeedList:       cfg.SeedList,
		DefaultPort:    cfg.DefaultPort,
		MinOutbound:    minConnections,
		MaxConnections: maxConnections,
		OnRollback:     nil, // Not implemented yet
	}

	service, err := spv.NewSPVService(&spvCfg)
	if err != nil {
		return nil, err
	}

	err = service.RegisterTransactionListener(&listener{
		address: cfg.GenesisAddress,
		service: service,
		db:      cfg.TxStore,
	})
	if err != nil {
		return nil, err
	}

	return &Service{SPVService: service, db: cfg.TxStore}, nil
}

func (s *Service) VerifyTransaction(tx *types.Transaction) error {
	payload, ok := tx.Payload.(*types.PayloadRechargeToSideChain)
	if !ok {
		return errors.New("[VerifyTransaction] Invalid payload core.PayloadRechargeToSideChain")
	}

	switch tx.PayloadVersion {
	case types.RechargeToSideChainPayloadVersion0:

		proof := new(bloom.MerkleProof)
		mainChainTransaction := new(core.Transaction)

		reader := bytes.NewReader(payload.MerkleProof)
		if err := proof.Deserialize(reader); err != nil {
			return errors.New("[VerifyTransaction] RechargeToSideChain payload deserialize failed")
		}

		reader = bytes.NewReader(payload.MainChainTransaction)
		if err := mainChainTransaction.Deserialize(reader); err != nil {
			return errors.New("[VerifyTransaction] RechargeToSideChain mainChainTransaction deserialize failed")
		}

		if err := s.SPVService.VerifyTransaction(*proof, *mainChainTransaction); err != nil {
			return errors.New("[VerifyTransaction] SPV module verify transaction failed.")
		}

	case types.RechargeToSideChainPayloadVersion1:

		_, err := s.db.Get(&payload.MainChainTransactionHash)
		if err != nil {
			return errors.New("[VerifyTransaction] Main chain transaction not found")
		}

	default:
		return errors.New("[VerifyTransaction] invalid payload version.")
	}

	return nil
}

func (s *Service) VerifyElaHeader(hash *common.Uint256) error {
	blockChain := s.HeaderStore()
	_, err := blockChain.Get(hash)
	if err != nil {
		return errors.New("[VerifyElaHeader] Verify ela header failed.")
	}
	return nil
}

type listener struct {
	address string
	service spv.SPVService
	db      *txStore

	mux sync.Mutex
}

func (l *listener) Address() string {
	return l.address
}

func (l *listener) Type() core.TransactionType {
	return core.TransferCrossChainAsset
}

func (l *listener) Flags() uint64 {
	return spv.FlagNotifyInSyncing
}

func (l *listener) Notify(id common.Uint256, proof bloom.MerkleProof, tx core.Transaction) {
	l.mux.Lock()
	defer l.mux.Unlock()

	txId := tx.Hash()
	_, err := l.db.Get(&txId)
	if err == nil {
		return
	}
	fmt.Println("[Notify] persist tx:", tx.Hash())

	if err := l.db.Put(&tx); err != nil {
		log.Errorf("[Notify] persist SPV transaction failed, err:", err.Error())
		return
	}

	// Submit transaction receipt
	l.service.SubmitTransactionReceipt(id, tx.Hash())
}
